<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Planet Of the Shapes</title>
    <style>
        body{
            background-color: aqua;
        }
        canvas{

        background-image:url("https://htmlcolorcodes.com/assets/images/html-color-codes-color-tutorials-hero-00e10b1f.jpg");
        background-repeat:no-repeat;
        background-size:cover;
}
        #canvas{
            margin: 20px;
            border: 1px solid orange;
        }

        #startBtn{
            position: absolute;
            top: 400px;
            left: 300px;
            width: 200px;
            height: 50px;
            font-size: 20px;
        }

    

     .instructions {
        position: absolute;
        box-sizing: border-box;
        display: none;
        background: black;
        color: white;
        max-width: 500px;
        max-height: 200px;
        margin: auto;
        font-size: 35px;
        border: 10px solid white;
        text-align: center;
      }

      .instructions {
        padding-top: 20px;
      }

      

     .instructions.active {
        display: block;
      }

      #game-over {
            display: none;
            text-align: center;
            font-size: 38px;
            /* padding-top: 92px; */
            /* z-index: 1; */
            /* width: 600px;
            height: 360px; */
            overflow: auto;
            top: 30%;
            left: 20%;
            color: white;
            /* margin: auto; */
            position: absolute;
        }

    .button {
            background-color: purple;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
        }

  


        
      #startGame{
            /* display: none; */
            text-align: center;
            font-size: 38px;
            /* padding-top: 92px; */
            /* z-index: 1; */
            /* width: 600px;
            height: 360px; */
            overflow: auto;
            top: 30%;
            left: 20%;
            color: white;
            /* margin: auto; */
            position: absolute;
        }

    /* .goPlay {
            background-color: purple;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
        } */
      
       
    
    </style>
    <link href="https://fonts.googleapis.com/css?family=Lexend+Peta&display=swap" rel="stylesheet">

    <script src="JS/soundEffect.js"></script>

</head>



<body>

        
    <canvas id="canvas" width="800" height="600"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <div id="startGame">

            <a href="javascript:void(0)" class="button play">Click Start to Play</a>
            
          </div>

    <div id="game-over">
            <h2>Your Score is <span id="score"></span> </h2>

            <a href="javascript:void(0)" class="button restart">Try again?</a>
            
          </div>
    


    <script>
        const FPS = 30; // frames per second
        const FRICTION = 0.7; // friction coefficient of space (0 = no friction, 1 = lots of friction)
        const startingLife = 3; // Number of starting life you have in a game

        const shootDistance = 0.6; // max distance laser can travel as fraction of screen width
        const bulletDur = 0.1; // duration of the bullet' explosion in seconds
        const bulletMax = 10; // number of bullets
        const bulletSpeed = 500; // bullet speed/s

        const largeShapePoint = 20; // points scored for a big shape
        const mediumShapePoint = 30; // points scored for a med shape
        const smallShapePoint = 50; // points scored for a small shape

        const shapeNum = 1; // starting number of shapes when a user play
        const shapeSize = 100; // in pixels
        const shapeSpeed = 50; // max  speed of shape in pixels per second was 50*****400 hard

        const SAVE_KEY_SCORE = "highscore"; // save key for local storage of high score

        const ShipBlinkDur = 0.1; // duration in seconds of a single blink during ship's invisibility
        const selfDestruck = 0.3; // duration of the ship's explosion in seconds
        const invisibility  = 0.4; // duration of the ship's invisibility in seconds
        const shipSize = 30; // ship height in pixels
        const shipAccel = 5; // acceleration of the ship in pixels per second per second
        const turnSpeed = 360; // turn speed in degrees per second
        const bounding = false; // show or hide collision bounding
        const dot = false; // show or hide ship's centre dot
        
        const textFading = 2.5; // text fade time in seconds
        const textsize = 40; // text font height in pixels
        var randomColor = "#" + Math.floor(Math.random()*16777215).toString(16); //generate a random color
        var randomColor2 = "#" + Math.floor(Math.random()*16777215).toString(16);
        var randomColor3 = "#" + Math.floor(Math.random()*16777215).toString(16);


        var canv = document.getElementById("canvas");
        var ctx = canv.getContext("2d");
        // var startBtn = document.getElementById('startBtn');


          $('.play').click(function() {
            $('#startGame').hide();
            newGame();
           

        }); 
        
        


        // set up the game parameters
        // var level, lives, container, score, scoreHigh, ship, text, textAlpha;
        // newGame();

        // set up event handlers
        document.addEventListener("keydown", keyDown);
        document.addEventListener("keyup", keyUp);

        // set up the game loop
        setInterval(update, 1000 / FPS);

        function createShape() {
            
            container = [];
            var x, y;

            for (var i = 0; i < shapeNum + level; i++) {
                // shape location
                do {
                    x = Math.floor(Math.random() * canv.width);
                    y = Math.floor(Math.random() * canv.height);
                } while (distBetweenPoints(ship.x, ship.y, x, y) < shapeSize * 2 + ship.r);
                container.push(newShape(x, y, Math.ceil(shapeSize / 2)));
            }
            
            
        }

        function killingShapes(index) {
            var x = container[index].x;
            var y = container[index].y;
            var r = container[index].r;

            // split shape once hit
            if (r == Math.ceil(shapeSize/ 2)) { // large asteroid
                container.push(newShape(x, y, Math.ceil(shapeSize / 4)));
                container.push(newShape(x, y, Math.ceil(shapeSize / 4)));
                shapeSplit.play();
                score += largeShapePoint;
            } else if (r == Math.ceil(shapeSize / 4)) { // medium asteroid
                container.push(newShape(x, y, Math.ceil(shapeSize / 8)));
                container.push(newShape(x, y, Math.ceil(shapeSize / 8)));
                shapeSplit.play();

                score += mediumShapePoint;
            } else {
                score += smallShapePoint;
                lastShapeGone.play();

            }

            // check high score
            if (score > scoreHigh) {
                scoreHigh = score;
                localStorage.setItem(SAVE_KEY_SCORE, scoreHigh);
            }

            // destroy the shape
            container.splice(index, 1);

            // new level happen once all shape is gone 
            if (container.length == 0) {
                level++;
                newLevel();
                passlev.play();
            }
        }

        function distBetweenPoints(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }
///make the red flying triangle
        function drawShip(x, y, a, colour = "white") {
            ctx.beginPath();
            ctx.strokeStyle = colour;
            ctx.lineWidth = 4;
            // shipSize / 20
            ctx.beginPath();
            ctx.moveTo( // nose of the ship
                x + 4 / 3 * ship.r * Math.cos(a),
                y - 4 / 3 * ship.r * Math.sin(a)
            );
            ctx.lineTo( // rear left
                x - ship.r * (2 / 3 * Math.cos(a) + Math.sin(a)),
                y + ship.r * (2 / 3 * Math.sin(a) - Math.cos(a))
            );
            ctx.lineTo( // rear right
                x - ship.r * (2 / 3 * Math.cos(a) - Math.sin(a)),
                y + ship.r * (2 / 3 * Math.sin(a) + Math.cos(a))
            );
            ctx.closePath();
            ctx.stroke();
            ctx.fillStyle = "red";
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "cyan";
            

        }

        function explodeShip() {
            ship.explodeTime = Math.ceil(selfDestruck  * FPS);
            crashexplo.play(); //sound when the ship self destruckt
        }

    
        

        function gameOver() {
            ship.dead = true;
            text = "Mission Failed ";
            myy.play();

            overPopUp()

            
        }

        function keyDown(/** @type {KeyboardEvent} */ ev) {

            if (ship.dead) {
                return;
            }

            switch(ev.keyCode) {
                case 32: // space bar: shooting
                    shootingAwsomeBullets();
                    break;
                case 37: // left arrow 
                    ship.rot = turnSpeed / 180 * Math.PI / FPS;
                    break;
                case 38: // up arrow: go forward
                    ship.thrusting = true;
                    break;
                case 39: // right arrow 
                    ship.rot = -turnSpeed / 180 * Math.PI / FPS;
                    break;
            }
        }

        function keyUp(/** @type {KeyboardEvent} */ ev) {

            if (ship.dead) {
                return;
            }

            switch(ev.keyCode) {
                case 32: // space bar: user can shoot
                    ship.canShoot = true;
                    break;
                case 37: // left arrow key
                    ship.rot = 0;
                    break;
                case 38: // up arrow key
                    ship.thrusting = false;
                    break;
                case 39: // right arrow key
                    ship.rot = 0;
                    break;
            }
        }
        

   


        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        function newShape(x, y, r) {
            var lvlMult = 1 + 0.1 * level;
            var roid = {
                x: x,
                y: y,
                xv: Math.random() * shapeSpeed * lvlMult / FPS * (Math.random() < 0.5 ? 1 : -1),
                yv: Math.random() * shapeSpeed * lvlMult / FPS * (Math.random() < 0.5 ? 1 : -1),
                a: Math.random() * Math.PI * 2, // in radians
                r: r,
                offs: [],
                vert: getRandomInt(3, 6) //generate random shapes based on sides
            };



            // making the shape, so it stay staight
            for (var i = 0; i < roid.vert; i++) {
                roid.offs.push(Math.random() * 0 * 2 + 1 - 0); //jaggedness of shape
            }

            return roid;
        }

        function newGame() {
            level = 0;
            lives = startingLife;
            score = 0;
            ship = newShip();

            // get the high score from local storage
            var scoreStr = localStorage.getItem(SAVE_KEY_SCORE);
            if (scoreStr == null) {
                scoreHigh = 0;
            } else {
                scoreHigh = parseInt(scoreStr);
            }

            newLevel();
        }
        
        //troll level

        // function bosslevel() {
        //     level = 0;
        //     lives = startingLife;
        //     shapeNum = 100;
        //     score = 0;
        //     ship = newShip();

        //     // get the high score from local storage
        //     var scoreStr = localStorage.getItem(SAVE_KEY_SCORE);
        //     if (scoreStr == null) {
        //         scoreHigh = 0;
        //     } else {
        //         scoreHigh = parseInt(scoreStr);
        //     }

        //     newLevel();
        // }

        function overPopUp() {
                // stop = true;
                $('#score').html(score);
                $('#game-over').show();
                
        }

        function newLevel() {
            text = "Level " + (level + 1);
            textAlpha = 1.0;
            createShape();
        }

        function newShip() {
            return {
                x: canv.width / 2,
                y: canv.height / 2,
                a: 90 / 180 * Math.PI, // convert to radians
                r: shipSize / 2,
                blinkNum: Math.ceil(invisibility / ShipBlinkDur),
                blinkTime: Math.ceil(ShipBlinkDur * FPS),
                canShoot: true,
                dead: false,
                explodeTime: 0,
                lasers: [],
                rot: 0,
                thrusting: false,
                thrust: {
                    x: 0,
                    y: 0
                }
            }
        }

        function shootingAwsomeBullets() {
            // create the bullet 
            if (ship.canShoot && ship.lasers.length < bulletMax ) {
                ship.lasers.push({ // from the nose of the ship
                    x: ship.x + 4 / 3 * ship.r * Math.cos(ship.a),
                    y: ship.y - 4 / 3 * ship.r * Math.sin(ship.a),
                    xv: bulletSpeed * Math.cos(ship.a) / FPS,
                    yv: -bulletSpeed * Math.sin(ship.a) / FPS,
                    dist: 0,
                    explodeTime: 0
                });
                bulletSound.play()
            }

            // prevent further shooting lol
            ship.canShoot = false;
        }

        function update() {


            var blinkOn = ship.blinkNum % 2 == 0;
            var exploding = ship.explodeTime > 0;



            // draw space
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canv.width, canv.height);

            // draw shape
            ctx.beginPath();

            var a, r, x, y, offs, vert;
            for (var i = 0; i < container.length; i++) {
                ctx.lineWidth = 8;

                ctx.strokeStyle = "#ffff00";
                // ctx.lineWidth = shipsize / 20;

                // get the asteroid properties
                a = container[i].a;
                r = container[i].r;
                x = container[i].x;
                y = container[i].y;
                offs = container[i].offs;
                vert = container[i].vert;
                
                // draw the path
                ctx.beginPath();
                ctx.moveTo(
                    x + r * offs[0] * Math.cos(a),
                    y + r * offs[0] * Math.sin(a)
                );

                // draw the shpaes
                for (var j = 1; j < vert; j++) {
                    ctx.lineTo(
                        x + r * offs[j] * Math.cos(a + j * Math.PI * 2 / vert),
                        y + r * offs[j] * Math.sin(a + j * Math.PI * 2 / vert)
                    );
                }
                ctx.closePath();
                ctx.stroke();

                // collision
                if (bounding) {
                    ctx.strokeStyle = "lime";
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2, false);
                    ctx.stroke();
                }
                ctx.fillStyle = randomColor;
                ctx.fill();
            }
            
            // ships engine
            if (ship.thrusting && !ship.dead) {
                ship.thrust.x += shipAccel * Math.cos(ship.a) / FPS;
                ship.thrust.y -= shipAccel * Math.sin(ship.a) / FPS;
                engine.play(); //start the sound of the engine

                // ship engine
                if (!exploding && blinkOn) {
                    ctx.fillStyle = randomColor2;
                    ctx.strokeStyle = randomColor3;
                    ctx.lineWidth = shipSize / 10;
                    ctx.beginPath();
                    ctx.moveTo( // rear left
                        ship.x - ship.r * (2 / 3 * Math.cos(ship.a) + 0.5 * Math.sin(ship.a)),
                        ship.y + ship.r * (2 / 3 * Math.sin(ship.a) - 0.5 * Math.cos(ship.a))
                    );
                    ctx.lineTo( // rear centre (behind the ship)
                        ship.x - ship.r * 5 / 3 * Math.cos(ship.a),
                        ship.y + ship.r * 5 / 3 * Math.sin(ship.a)
                    );
                    ctx.lineTo( // rear right
                        ship.x - ship.r * (2 / 3 * Math.cos(ship.a) - 0.5 * Math.sin(ship.a)),
                        ship.y + ship.r * (2 / 3 * Math.sin(ship.a) + 0.5 * Math.cos(ship.a))
                    );
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            } else {
                ship.thrust.x -= FRICTION * ship.thrust.x / FPS;
                ship.thrust.y -= FRICTION * ship.thrust.y / FPS;
                engine.stop();
            }
            
            if (!exploding) {
                if (blinkOn && !ship.dead) {
                    drawShip(ship.x, ship.y, ship.a);
                }

                // handle blinking
                if (ship.blinkNum > 0) {

                    // reduce the blink time
                    ship.blinkTime--;

                    // reduce the blink num
                    if (ship.blinkTime == 0) {
                        ship.blinkTime = Math.ceil(ShipBlinkDur * FPS);
                        ship.blinkNum--;
                    }
                }
            } else {
                // draw boom boom color
                ctx.fillStyle = "darkred";
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, ship.r * 1.7, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, ship.r * 1.4, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.fillStyle = "orange";
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, ship.r * 1.1, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.fillStyle = "yellow";
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, ship.r * 0.8, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, ship.r * 0.5, 0, Math.PI * 2, false);
                ctx.fill();
            }

            // show  collision 
            if (bounding) {
                ctx.strokeStyle = "lime";
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, ship.r, 0, Math.PI * 2, false);
                ctx.stroke();
            }
            
            // show s
            // if (dot) {
            //     ctx.fillStyle = "green";
            //     ctx.fillRect(ship.x - 1, ship.y - 1, 2, 2);
            // }

            // draw bullet
            for (var i = 0; i < ship.lasers.length; i++) {
                if (ship.lasers[i].explodeTime == 0) {
                    ctx.fillStyle = "yellow";
                    ctx.beginPath();
                    ctx.arc(ship.lasers[i].x, ship.lasers[i].y, shipSize/ 15, 0, Math.PI * 2, false);
                    ctx.fill();
                } else {
                    // draw  the boom boom once shape is killed
                    ctx.fillStyle = "orangered";
                    ctx.beginPath();
                    ctx.arc(ship.lasers[i].x, ship.lasers[i].y, ship.r * 0.75, 0, Math.PI * 2, false);
                    ctx.fill();
                    ctx.fillStyle = "salmon";
                    ctx.beginPath();
                    ctx.arc(ship.lasers[i].x, ship.lasers[i].y, ship.r * 0.5, 0, Math.PI * 2, false);
                    ctx.fill();
                    ctx.fillStyle = "pink";
                    ctx.beginPath();
                    ctx.arc(ship.lasers[i].x, ship.lasers[i].y, ship.r * 0.25, 0, Math.PI * 2, false);
                    ctx.fill();
                }
            }
            // ctx.fillText("Score: " + score, canv.width - shipSize / 2, shipSize);
            
            // draw the game text
            if (textAlpha >= 0) {
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = "white";
                ctx.font = textsize+ "px 'Lexend Peta', sans-serif";
                ctx.fillText(text, canv.width / 2, canv.height * 0.1);

                // ctx.fillText(text, canv.width / 2, canv.height * 0.75);
                // ctx.fillText(text, canv.width - shipSize / 2, shipSize);
                // textAlpha -= (1.0 / textFading / FPS);
            } else if (ship.dead) {
                // after "game over" fades, start a new game
                newGame();
                //add event listener to here click to start a new game
            }

            // draw the lives
            
            for (var i = 0; i < lives; i++) {
                lifeColour = exploding && i == lives - 1 ? "red" : "yellow"; //start to disappear once you are killed
                drawShip(shipSize + i * shipSize * 1.2, shipSize, 0.5 * Math.PI, lifeColour);
                
            }

            // draw the score
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "red";
            ctx.font = 40 + "px dejavu sans mono";
            // ctx.fillText("Score: " + score, canv.width / 2, shipSize)
            ctx.fillText("Score: " + score, canv.width - shipSize / 2, shipSize);

            // draw the high score
            // ctx.textAlign = "center";
            // ctx.textBaseline = "middle";
            // ctx.fillStyle = "white";
            // ctx.font = (textsize * 0.75) + "px dejavu sans mono";
            // ctx.fillText("BEST " + scoreHigh, canv.width / 2, shipSize);


            var ax, ay, ar, lx, ly;
            for (var i = container.length - 1; i >= 0; i--) {

             
                ax = container[i].x;
                ay = container[i].y;
                ar = container[i].r;

              
                for (var j = ship.lasers.length - 1; j >= 0; j--) {

                    
                    lx = ship.lasers[j].x;
                    ly = ship.lasers[j].y;

                    // detect hits
                    if (ship.lasers[j].explodeTime == 0 && distBetweenPoints(ax, ay, lx, ly) < ar) {

                        // shape is gone once hit and activate booooooom
                        killingShapes(i);
                        ship.lasers[j].explodeTime = Math.ceil(bulletDur * FPS);
                        break;
                    }
                }
            }

            // ship colide
            if (!exploding) {

                // if it is not blinking
                if (ship.blinkNum == 0 && !ship.dead) {
                    for (var i = 0; i < container.length; i++) {
                        if (distBetweenPoints(ship.x, ship.y, container[i].x, container[i].y) < ship.r + container[i].r) {
                            explodeShip();
                            killingShapes(i);
                            break;
                        }
                    }
                }

                // rotating
                ship.a += ship.rot;

                // ship moveing in the canvas
                ship.x += ship.thrust.x;
                ship.y += ship.thrust.y;
            } else {
                
                ship.explodeTime--;

                // ship get right backup after it dies
                if (ship.explodeTime == 0) {
                    lives--;
                    if (lives == 0) {
                        gameOver();
                    } else {
                        ship = newShip();
                    }
                }
            }

           
            if (ship.x < 0 - ship.r) {
                ship.x = canv.width + ship.r;
            } else if (ship.x > canv.width + ship.r) {
                ship.x = 0 - ship.r;
            }
            if (ship.y < 0 - ship.r) {
                ship.y = canv.height + ship.r;
            } else if (ship.y > canv.height + ship.r) {
                ship.y = 0 - ship.r;
            }

                                
        // move the shooting thingy
            for (var i = ship.lasers.length - 1; i >= 0; i--) {
                
                
                if (ship.lasers[i].dist > shootDistance * canv.width) {
                    ship.lasers.splice(i, 1);
                    continue;
                }

                //  explosion
                if (ship.lasers[i].explodeTime > 0) {
                    ship.lasers[i].explodeTime--;

                    // destroy  after the duration is up
                    if (ship.lasers[i].explodeTime == 0) {
                        ship.lasers.splice(i, 1);
                        continue;
                    }
                } else {
                    // move the shooting thingy
                    ship.lasers[i].x += ship.lasers[i].xv;
                    ship.lasers[i].y += ship.lasers[i].yv;

                   
                    ship.lasers[i].dist += Math.sqrt(Math.pow(ship.lasers[i].xv, 2) + Math.pow(ship.lasers[i].yv, 2));
                }

               
                if (ship.lasers[i].x < 0) {
                    ship.lasers[i].x = canv.width;
                } else if (ship.lasers[i].x > canv.width) {
                    ship.lasers[i].x = 0;
                }
                if (ship.lasers[i].y < 0) {
                    ship.lasers[i].y = canv.height;
                } else if (ship.lasers[i].y > canv.height) {
                    ship.lasers[i].y = 0;
                }
            }

            // shape moving in the canvas
            for (var i = 0; i < container.length; i++) {
                container[i].x += container[i].xv;
                container[i].y += container[i].yv;

                
                if (container[i].x < 0 - container[i].r) {
                    container[i].x = canv.width + container[i].r;
                } else if (container[i].x > canv.width + container[i].r) {
                    container[i].x = 0 - container[i].r
                }
                if (container[i].y < 0 - container[i].r) {
                    container[i].y = canv.height + container[i].r;
                } else if (container[i].y > canv.height + container[i].r) {
                    container[i].y = 0 - container[i].r
                }
            }
        }



 
      

        $('.restart').click(function() {
            $('#game-over').hide();
            newGame();
            // pauseAudio()

        });

        
    </script>
    




<div class="instructions active">
        Press LEFT, and RIGHT to turn, and UP to propel.
        <br>
        Press SPACE to fire bullets.
        
    </div>

  
    

</body>

</html>